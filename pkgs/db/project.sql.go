// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO core.project (
    project_code,
    project_name,
    metadata
) VALUES (
    $1, $2, $3
)
RETURNING project_name, metadata, project_code
`

type CreateProjectParams struct {
	ProjectCode string `json:"project_code"`
	ProjectName string `json:"project_name"`
	Metadata    []byte `json:"metadata"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (CoreProject, error) {
	row := q.db.QueryRow(ctx, createProject, arg.ProjectCode, arg.ProjectName, arg.Metadata)
	var i CoreProject
	err := row.Scan(&i.ProjectName, &i.Metadata, &i.ProjectCode)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM core.project
WHERE project_code = $1
`

func (q *Queries) DeleteProject(ctx context.Context, projectCode string) error {
	_, err := q.db.Exec(ctx, deleteProject, projectCode)
	return err
}

const getProject = `-- name: GetProject :one
SELECT project_name, metadata, project_code FROM core.project
WHERE project_code = $1
`

func (q *Queries) GetProject(ctx context.Context, projectCode string) (CoreProject, error) {
	row := q.db.QueryRow(ctx, getProject, projectCode)
	var i CoreProject
	err := row.Scan(&i.ProjectName, &i.Metadata, &i.ProjectCode)
	return i, err
}

const getProjectWithTreeCount = `-- name: GetProjectWithTreeCount :one
SELECT 
    t.project_code,
    t.project_name,
    t.metadata,
    COUNT(tr.id) as tree_count
FROM core.project t
LEFT JOIN core.tree tr ON t.project_code = tr.project_code
WHERE t.project_code = $1
GROUP BY t.project_code, t.project_name, t.metadata
`

type GetProjectWithTreeCountRow struct {
	ProjectCode string `json:"project_code"`
	ProjectName string `json:"project_name"`
	Metadata    []byte `json:"metadata"`
	TreeCount   int64  `json:"tree_count"`
}

func (q *Queries) GetProjectWithTreeCount(ctx context.Context, projectCode string) (GetProjectWithTreeCountRow, error) {
	row := q.db.QueryRow(ctx, getProjectWithTreeCount, projectCode)
	var i GetProjectWithTreeCountRow
	err := row.Scan(
		&i.ProjectCode,
		&i.ProjectName,
		&i.Metadata,
		&i.TreeCount,
	)
	return i, err
}

const listProjects = `-- name: ListProjects :many
SELECT project_name, metadata, project_code FROM core.project
ORDER BY project_name
`

func (q *Queries) ListProjects(ctx context.Context) ([]CoreProject, error) {
	rows, err := q.db.Query(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreProject{}
	for rows.Next() {
		var i CoreProject
		if err := rows.Scan(&i.ProjectName, &i.Metadata, &i.ProjectCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsWithTreeCounts = `-- name: ListProjectsWithTreeCounts :many
SELECT 
    t.project_code,
    t.project_name,
    t.metadata,
    COUNT(tr.id) as tree_count
FROM core.project t
LEFT JOIN core.tree tr ON t.project_code = tr.project_code
GROUP BY t.project_code, t.project_name, t.metadata
ORDER BY t.project_name
`

type ListProjectsWithTreeCountsRow struct {
	ProjectCode string `json:"project_code"`
	ProjectName string `json:"project_name"`
	Metadata    []byte `json:"metadata"`
	TreeCount   int64  `json:"tree_count"`
}

func (q *Queries) ListProjectsWithTreeCounts(ctx context.Context) ([]ListProjectsWithTreeCountsRow, error) {
	rows, err := q.db.Query(ctx, listProjectsWithTreeCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectsWithTreeCountsRow{}
	for rows.Next() {
		var i ListProjectsWithTreeCountsRow
		if err := rows.Scan(
			&i.ProjectCode,
			&i.ProjectName,
			&i.Metadata,
			&i.TreeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjects = `-- name: SearchProjects :many
SELECT project_name, metadata, project_code
FROM core.project
WHERE project_name ILIKE '%' || $1 || '%' OR project_code ILIKE '%' || $1 || '%'
ORDER BY project_name
`

func (q *Queries) SearchProjects(ctx context.Context, dollar_1 pgtype.Text) ([]CoreProject, error) {
	rows, err := q.db.Query(ctx, searchProjects, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreProject{}
	for rows.Next() {
		var i CoreProject
		if err := rows.Scan(&i.ProjectName, &i.Metadata, &i.ProjectCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
UPDATE core.project
SET 
    project_name = $2,
    metadata = $3
WHERE project_code = $1
RETURNING project_name, metadata, project_code
`

type UpdateProjectParams struct {
	ProjectCode string `json:"project_code"`
	ProjectName string `json:"project_name"`
	Metadata    []byte `json:"metadata"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (CoreProject, error) {
	row := q.db.QueryRow(ctx, updateProject, arg.ProjectCode, arg.ProjectName, arg.Metadata)
	var i CoreProject
	err := row.Scan(&i.ProjectName, &i.Metadata, &i.ProjectCode)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tree.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTree = `-- name: CreateTree :one
INSERT INTO core.tree (
    town_code,
    tree_number,
    donor_id,
    tree_location,
    planted_at,
    metadata
) VALUES (
    $1, $2, $3, ST_SetSRID(ST_MakePoint($4, $5), 4326)::geography, $6, $7
)
RETURNING id, town_code, tree_number, donor_id, planted_at, created_at, metadata
`

type CreateTreeParams struct {
	TownCode      string             `json:"town_code"`
	TreeNumber    int32              `json:"tree_number"`
	DonorID       string             `json:"donor_id"`
	StMakepoint   interface{}        `json:"st_makepoint"`
	StMakepoint_2 interface{}        `json:"st_makepoint_2"`
	PlantedAt     pgtype.Timestamptz `json:"planted_at"`
	Metadata      []byte             `json:"metadata"`
}

type CreateTreeRow struct {
	ID         string             `json:"id"`
	TownCode   string             `json:"town_code"`
	TreeNumber int32              `json:"tree_number"`
	DonorID    string             `json:"donor_id"`
	PlantedAt  pgtype.Timestamptz `json:"planted_at"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Metadata   []byte             `json:"metadata"`
}

// Insert a new tree
func (q *Queries) CreateTree(ctx context.Context, arg CreateTreeParams) (CreateTreeRow, error) {
	row := q.db.QueryRow(ctx, createTree,
		arg.TownCode,
		arg.TreeNumber,
		arg.DonorID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.PlantedAt,
		arg.Metadata,
	)
	var i CreateTreeRow
	err := row.Scan(
		&i.ID,
		&i.TownCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getClusterDetail = `-- name: GetClusterDetail :one
SELECT 
    tw.town_code,
    tw.town_name,
    tw.metadata as town_metadata,
    COUNT(t.id) as tree_count,
    AVG(ST_Y(t.tree_location::geometry))::FLOAT as center_lat,
    AVG(ST_X(t.tree_location::geometry))::FLOAT as center_lng,
    MIN(t.planted_at)::timestamptz as first_planted,
    MAX(t.planted_at)::timestamptz as last_planted,
    COUNT(DISTINCT t.donor_id) as unique_donors
FROM core.town tw
LEFT JOIN core.tree t ON tw.town_code = t.town_code
WHERE tw.town_code = $1
GROUP BY tw.town_code, tw.town_name, tw.metadata
`

type GetClusterDetailRow struct {
	TownCode     string             `json:"town_code"`
	TownName     string             `json:"town_name"`
	TownMetadata []byte             `json:"town_metadata"`
	TreeCount    int64              `json:"tree_count"`
	CenterLat    float64            `json:"center_lat"`
	CenterLng    float64            `json:"center_lng"`
	FirstPlanted pgtype.Timestamptz `json:"first_planted"`
	LastPlanted  pgtype.Timestamptz `json:"last_planted"`
	UniqueDonors int64              `json:"unique_donors"`
}

// Get detailed statistics for a town cluster
func (q *Queries) GetClusterDetail(ctx context.Context, townCode string) (GetClusterDetailRow, error) {
	row := q.db.QueryRow(ctx, getClusterDetail, townCode)
	var i GetClusterDetailRow
	err := row.Scan(
		&i.TownCode,
		&i.TownName,
		&i.TownMetadata,
		&i.TreeCount,
		&i.CenterLat,
		&i.CenterLng,
		&i.FirstPlanted,
		&i.LastPlanted,
		&i.UniqueDonors,
	)
	return i, err
}

const getIndividualTrees = `-- name: GetIndividualTrees :many
SELECT 
    t.id,
    t.town_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata,
    d.donor_name,
    tw.town_name
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
JOIN core.town tw ON t.town_code = tw.town_code
WHERE ST_Y(t.tree_location::geometry) BETWEEN $1 AND $2
  AND ST_X(t.tree_location::geometry) BETWEEN $3 AND $4
LIMIT $5
`

type GetIndividualTreesParams struct {
	SouthLat    interface{} `json:"south_lat"`
	NorthLat    interface{} `json:"north_lat"`
	WestLng     interface{} `json:"west_lng"`
	EastLng     interface{} `json:"east_lng"`
	ResultLimit int32       `json:"result_limit"`
}

type GetIndividualTreesRow struct {
	ID         string             `json:"id"`
	TownCode   string             `json:"town_code"`
	TreeNumber int32              `json:"tree_number"`
	DonorID    string             `json:"donor_id"`
	Latitude   float64            `json:"latitude"`
	Longitude  float64            `json:"longitude"`
	PlantedAt  pgtype.Timestamptz `json:"planted_at"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Metadata   []byte             `json:"metadata"`
	DonorName  string             `json:"donor_name"`
	TownName   string             `json:"town_name"`
}

// Zoom levels 13+: Return individual trees with details
func (q *Queries) GetIndividualTrees(ctx context.Context, arg GetIndividualTreesParams) ([]GetIndividualTreesRow, error) {
	rows, err := q.db.Query(ctx, getIndividualTrees,
		arg.SouthLat,
		arg.NorthLat,
		arg.WestLng,
		arg.EastLng,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetIndividualTreesRow{}
	for rows.Next() {
		var i GetIndividualTreesRow
		if err := rows.Scan(
			&i.ID,
			&i.TownCode,
			&i.TreeNumber,
			&i.DonorID,
			&i.Latitude,
			&i.Longitude,
			&i.PlantedAt,
			&i.CreatedAt,
			&i.Metadata,
			&i.DonorName,
			&i.TownName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreeByID = `-- name: GetTreeByID :one
SELECT 
    t.id,
    t.town_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata,
    d.donor_name,
    d.email as donor_email,
    tw.town_name,
    tw.metadata as town_metadata
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
JOIN core.town tw ON t.town_code = tw.town_code
WHERE t.id = $1
`

type GetTreeByIDRow struct {
	ID           string             `json:"id"`
	TownCode     string             `json:"town_code"`
	TreeNumber   int32              `json:"tree_number"`
	DonorID      string             `json:"donor_id"`
	Latitude     float64            `json:"latitude"`
	Longitude    float64            `json:"longitude"`
	PlantedAt    pgtype.Timestamptz `json:"planted_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Metadata     []byte             `json:"metadata"`
	DonorName    string             `json:"donor_name"`
	DonorEmail   string             `json:"donor_email"`
	TownName     string             `json:"town_name"`
	TownMetadata []byte             `json:"town_metadata"`
}

// Get a single tree by ID with full details
func (q *Queries) GetTreeByID(ctx context.Context, id string) (GetTreeByIDRow, error) {
	row := q.db.QueryRow(ctx, getTreeByID, id)
	var i GetTreeByIDRow
	err := row.Scan(
		&i.ID,
		&i.TownCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.Latitude,
		&i.Longitude,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
		&i.DonorName,
		&i.DonorEmail,
		&i.TownName,
		&i.TownMetadata,
	)
	return i, err
}

const getTreeCount = `-- name: GetTreeCount :one
SELECT COUNT(*) as total
FROM core.tree t
WHERE ($1::CHAR(2) IS NULL OR t.town_code = $1)
`

// Get total tree count, optionally filtered by town
func (q *Queries) GetTreeCount(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, getTreeCount, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTreesByGridCluster = `-- name: GetTreesByGridCluster :many
WITH params AS (
    SELECT 
        $1::float8 as grid_size,
        $2::float8 as west_lng,
        $3::float8 as south_lat,
        $4::float8 as east_lng,
        $5::float8 as north_lat
)
SELECT 
    ST_Y(ST_SnapToGrid(t.tree_location::geometry, p.grid_size, p.grid_size))::FLOAT as grid_lat,
    ST_X(ST_SnapToGrid(t.tree_location::geometry, p.grid_size, p.grid_size))::FLOAT as grid_lng,
    COUNT(*) as tree_count,
    ARRAY_AGG(t.id)::VARCHAR[] as tree_ids
FROM core.tree t
CROSS JOIN params p
WHERE t.tree_location && ST_MakeEnvelope(p.west_lng, p.south_lat, p.east_lng, p.north_lat, 4326)::geography
GROUP BY ST_SnapToGrid(t.tree_location::geometry, p.grid_size, p.grid_size)
HAVING COUNT(*) > 0
`

type GetTreesByGridClusterParams struct {
	GridSize float64 `json:"grid_size"`
	WestLng  float64 `json:"west_lng"`
	SouthLat float64 `json:"south_lat"`
	EastLng  float64 `json:"east_lng"`
	NorthLat float64 `json:"north_lat"`
}

type GetTreesByGridClusterRow struct {
	GridLat   float64  `json:"grid_lat"`
	GridLng   float64  `json:"grid_lng"`
	TreeCount int64    `json:"tree_count"`
	TreeIds   []string `json:"tree_ids"`
}

// Zoom levels 9-12: Grid-based clustering for medium zoom
func (q *Queries) GetTreesByGridCluster(ctx context.Context, arg GetTreesByGridClusterParams) ([]GetTreesByGridClusterRow, error) {
	rows, err := q.db.Query(ctx, getTreesByGridCluster,
		arg.GridSize,
		arg.WestLng,
		arg.SouthLat,
		arg.EastLng,
		arg.NorthLat,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreesByGridClusterRow{}
	for rows.Next() {
		var i GetTreesByGridClusterRow
		if err := rows.Scan(
			&i.GridLat,
			&i.GridLng,
			&i.TreeCount,
			&i.TreeIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreesByTownCluster = `-- name: GetTreesByTownCluster :many
SELECT 
    t.town_code,
    tw.town_name,
    COUNT(*) as tree_count,
    AVG(ST_Y(t.tree_location::geometry))::FLOAT as center_lat,
    AVG(ST_X(t.tree_location::geometry))::FLOAT as center_lng
FROM core.tree t
JOIN core.town tw ON t.town_code = tw.town_code
WHERE ST_Y(t.tree_location::geometry) BETWEEN $1 AND $2
  AND ST_X(t.tree_location::geometry) BETWEEN $3 AND $4
GROUP BY t.town_code, tw.town_name
`

type GetTreesByTownClusterParams struct {
	SouthLat interface{} `json:"south_lat"`
	NorthLat interface{} `json:"north_lat"`
	WestLng  interface{} `json:"west_lng"`
	EastLng  interface{} `json:"east_lng"`
}

type GetTreesByTownClusterRow struct {
	TownCode  string  `json:"town_code"`
	TownName  string  `json:"town_name"`
	TreeCount int64   `json:"tree_count"`
	CenterLat float64 `json:"center_lat"`
	CenterLng float64 `json:"center_lng"`
}

// Zoom levels 1-8: Get tree counts grouped by town
func (q *Queries) GetTreesByTownCluster(ctx context.Context, arg GetTreesByTownClusterParams) ([]GetTreesByTownClusterRow, error) {
	rows, err := q.db.Query(ctx, getTreesByTownCluster,
		arg.SouthLat,
		arg.NorthLat,
		arg.WestLng,
		arg.EastLng,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreesByTownClusterRow{}
	for rows.Next() {
		var i GetTreesByTownClusterRow
		if err := rows.Scan(
			&i.TownCode,
			&i.TownName,
			&i.TreeCount,
			&i.CenterLat,
			&i.CenterLng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreesByTownCode = `-- name: GetTreesByTownCode :many
SELECT 
    t.id,
    t.tree_number,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.metadata,
    d.donor_name
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
WHERE t.town_code = $1
ORDER BY t.tree_number
`

type GetTreesByTownCodeRow struct {
	ID         string             `json:"id"`
	TreeNumber int32              `json:"tree_number"`
	Latitude   float64            `json:"latitude"`
	Longitude  float64            `json:"longitude"`
	PlantedAt  pgtype.Timestamptz `json:"planted_at"`
	Metadata   []byte             `json:"metadata"`
	DonorName  string             `json:"donor_name"`
}

// Get all trees in a specific town
func (q *Queries) GetTreesByTownCode(ctx context.Context, townCode string) ([]GetTreesByTownCodeRow, error) {
	rows, err := q.db.Query(ctx, getTreesByTownCode, townCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreesByTownCodeRow{}
	for rows.Next() {
		var i GetTreesByTownCodeRow
		if err := rows.Scan(
			&i.ID,
			&i.TreeNumber,
			&i.Latitude,
			&i.Longitude,
			&i.PlantedAt,
			&i.Metadata,
			&i.DonorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

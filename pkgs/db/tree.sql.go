// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tree.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTree = `-- name: CreateTree :one
INSERT INTO core.tree (
    project_code,
    tree_number,
    donor_id,
    tree_location,
    planted_at,
    metadata
) VALUES (
    $1, $2, $3, ST_SetSRID(ST_MakePoint($4, $5), 4326)::geography, $6, $7
)
RETURNING id, project_code, tree_number, donor_id, planted_at, created_at, metadata
`

type CreateTreeParams struct {
	ProjectCode   string             `json:"project_code"`
	TreeNumber    int32              `json:"tree_number"`
	DonorID       string             `json:"donor_id"`
	StMakepoint   interface{}        `json:"st_makepoint"`
	StMakepoint_2 interface{}        `json:"st_makepoint_2"`
	PlantedAt     pgtype.Timestamptz `json:"planted_at"`
	Metadata      []byte             `json:"metadata"`
}

type CreateTreeRow struct {
	ID          string             `json:"id"`
	ProjectCode string             `json:"project_code"`
	TreeNumber  int32              `json:"tree_number"`
	DonorID     string             `json:"donor_id"`
	PlantedAt   pgtype.Timestamptz `json:"planted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Metadata    []byte             `json:"metadata"`
}

// Insert a new tree
func (q *Queries) CreateTree(ctx context.Context, arg CreateTreeParams) (CreateTreeRow, error) {
	row := q.db.QueryRow(ctx, createTree,
		arg.ProjectCode,
		arg.TreeNumber,
		arg.DonorID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.PlantedAt,
		arg.Metadata,
	)
	var i CreateTreeRow
	err := row.Scan(
		&i.ID,
		&i.ProjectCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getClusterDetail = `-- name: GetClusterDetail :one
SELECT 
    tw.project_code,
    tw.project_name,
    tw.metadata as project_metadata,
    COUNT(t.id) as tree_count,
    AVG(ST_Y(t.tree_location::geometry))::FLOAT as center_lat,
    AVG(ST_X(t.tree_location::geometry))::FLOAT as center_lng,
    MIN(t.planted_at)::timestamptz as first_planted,
    MAX(t.planted_at)::timestamptz as last_planted,
    COUNT(DISTINCT t.donor_id) as unique_donors
FROM core.project tw
LEFT JOIN core.tree t ON tw.project_code = t.project_code
WHERE tw.project_code = $1
GROUP BY tw.project_code, tw.project_name, tw.metadata
`

type GetClusterDetailRow struct {
	ProjectCode     string             `json:"project_code"`
	ProjectName     string             `json:"project_name"`
	ProjectMetadata []byte             `json:"project_metadata"`
	TreeCount       int64              `json:"tree_count"`
	CenterLat       float64            `json:"center_lat"`
	CenterLng       float64            `json:"center_lng"`
	FirstPlanted    pgtype.Timestamptz `json:"first_planted"`
	LastPlanted     pgtype.Timestamptz `json:"last_planted"`
	UniqueDonors    int64              `json:"unique_donors"`
}

// Get detailed statistics for a project cluster
func (q *Queries) GetClusterDetail(ctx context.Context, projectCode string) (GetClusterDetailRow, error) {
	row := q.db.QueryRow(ctx, getClusterDetail, projectCode)
	var i GetClusterDetailRow
	err := row.Scan(
		&i.ProjectCode,
		&i.ProjectName,
		&i.ProjectMetadata,
		&i.TreeCount,
		&i.CenterLat,
		&i.CenterLng,
		&i.FirstPlanted,
		&i.LastPlanted,
		&i.UniqueDonors,
	)
	return i, err
}

const getDonorIndividualTrees = `-- name: GetDonorIndividualTrees :many
SELECT 
    t.id,
    t.project_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata,
    d.donor_name,
    tw.project_name
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
JOIN core.project tw ON t.project_code = tw.project_code
WHERE ST_Y(t.tree_location::geometry) BETWEEN $1 AND $2
  AND ST_X(t.tree_location::geometry) BETWEEN $3 AND $4
  AND t.donor_id = $5
LIMIT $6
`

type GetDonorIndividualTreesParams struct {
	SouthLat    interface{} `json:"south_lat"`
	NorthLat    interface{} `json:"north_lat"`
	WestLng     interface{} `json:"west_lng"`
	EastLng     interface{} `json:"east_lng"`
	DonorID     string      `json:"donor_id"`
	ResultLimit int32       `json:"result_limit"`
}

type GetDonorIndividualTreesRow struct {
	ID          string             `json:"id"`
	ProjectCode string             `json:"project_code"`
	TreeNumber  int32              `json:"tree_number"`
	DonorID     string             `json:"donor_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	PlantedAt   pgtype.Timestamptz `json:"planted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Metadata    []byte             `json:"metadata"`
	DonorName   string             `json:"donor_name"`
	ProjectName string             `json:"project_name"`
}

// Zoom levels 13+: Return individual trees with details
func (q *Queries) GetDonorIndividualTrees(ctx context.Context, arg GetDonorIndividualTreesParams) ([]GetDonorIndividualTreesRow, error) {
	rows, err := q.db.Query(ctx, getDonorIndividualTrees,
		arg.SouthLat,
		arg.NorthLat,
		arg.WestLng,
		arg.EastLng,
		arg.DonorID,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDonorIndividualTreesRow{}
	for rows.Next() {
		var i GetDonorIndividualTreesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectCode,
			&i.TreeNumber,
			&i.DonorID,
			&i.Latitude,
			&i.Longitude,
			&i.PlantedAt,
			&i.CreatedAt,
			&i.Metadata,
			&i.DonorName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonorTreesByGridCluster = `-- name: GetDonorTreesByGridCluster :many
WITH params AS (
    SELECT 
        $2::float8 as grid_size,
        $3::float8 as west_lng,
        $4::float8 as south_lat,
        $5::float8 as east_lng,
        $6::float8 as north_lat
)
SELECT 
    ST_Y(ST_SnapToGrid(t.tree_location::geometry, p.grid_size, p.grid_size))::FLOAT as grid_lat,
    ST_X(ST_SnapToGrid(t.tree_location::geometry, p.grid_size, p.grid_size))::FLOAT as grid_lng,
    COUNT(*) as tree_count,
    ARRAY_AGG(t.id)::VARCHAR[] as tree_ids
FROM core.tree t
CROSS JOIN params p
WHERE t.tree_location && ST_MakeEnvelope(p.west_lng, p.south_lat, p.east_lng, p.north_lat, 4326)::geography
    AND t.donor_id = $1::CHAR(21)
GROUP BY ST_SnapToGrid(t.tree_location::geometry, p.grid_size, p.grid_size)
HAVING COUNT(*) > 0
`

type GetDonorTreesByGridClusterParams struct {
	DonorID  string  `json:"donor_id"`
	GridSize float64 `json:"grid_size"`
	WestLng  float64 `json:"west_lng"`
	SouthLat float64 `json:"south_lat"`
	EastLng  float64 `json:"east_lng"`
	NorthLat float64 `json:"north_lat"`
}

type GetDonorTreesByGridClusterRow struct {
	GridLat   float64  `json:"grid_lat"`
	GridLng   float64  `json:"grid_lng"`
	TreeCount int64    `json:"tree_count"`
	TreeIds   []string `json:"tree_ids"`
}

// Zoom levels 9-12: Grid-based clustering for medium zoom
func (q *Queries) GetDonorTreesByGridCluster(ctx context.Context, arg GetDonorTreesByGridClusterParams) ([]GetDonorTreesByGridClusterRow, error) {
	rows, err := q.db.Query(ctx, getDonorTreesByGridCluster,
		arg.DonorID,
		arg.GridSize,
		arg.WestLng,
		arg.SouthLat,
		arg.EastLng,
		arg.NorthLat,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDonorTreesByGridClusterRow{}
	for rows.Next() {
		var i GetDonorTreesByGridClusterRow
		if err := rows.Scan(
			&i.GridLat,
			&i.GridLng,
			&i.TreeCount,
			&i.TreeIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDonorTreesByProjectCluster = `-- name: GetDonorTreesByProjectCluster :many
SELECT 
    t.project_code,
    tw.project_name,
    COUNT(*) as tree_count,
    AVG(ST_Y(t.tree_location::geometry))::FLOAT as center_lat,
    AVG(ST_X(t.tree_location::geometry))::FLOAT as center_lng
FROM core.tree t
JOIN core.project tw ON t.project_code = tw.project_code
WHERE ST_Y(t.tree_location::geometry) BETWEEN $1 AND $2
  AND ST_X(t.tree_location::geometry) BETWEEN $3 AND $4
  AND t.donor_id = $5
GROUP BY t.project_code, tw.project_name
`

type GetDonorTreesByProjectClusterParams struct {
	SouthLat interface{} `json:"south_lat"`
	NorthLat interface{} `json:"north_lat"`
	WestLng  interface{} `json:"west_lng"`
	EastLng  interface{} `json:"east_lng"`
	DonorID  string      `json:"donor_id"`
}

type GetDonorTreesByProjectClusterRow struct {
	ProjectCode string  `json:"project_code"`
	ProjectName string  `json:"project_name"`
	TreeCount   int64   `json:"tree_count"`
	CenterLat   float64 `json:"center_lat"`
	CenterLng   float64 `json:"center_lng"`
}

// Zoom levels 1-8: Get tree counts grouped by project
func (q *Queries) GetDonorTreesByProjectCluster(ctx context.Context, arg GetDonorTreesByProjectClusterParams) ([]GetDonorTreesByProjectClusterRow, error) {
	rows, err := q.db.Query(ctx, getDonorTreesByProjectCluster,
		arg.SouthLat,
		arg.NorthLat,
		arg.WestLng,
		arg.EastLng,
		arg.DonorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDonorTreesByProjectClusterRow{}
	for rows.Next() {
		var i GetDonorTreesByProjectClusterRow
		if err := rows.Scan(
			&i.ProjectCode,
			&i.ProjectName,
			&i.TreeCount,
			&i.CenterLat,
			&i.CenterLng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndividualTrees = `-- name: GetIndividualTrees :many
SELECT 
    t.id,
    t.project_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata,
    d.donor_name,
    tw.project_name
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
JOIN core.project tw ON t.project_code = tw.project_code
WHERE ST_Y(t.tree_location::geometry) BETWEEN $1 AND $2
  AND ST_X(t.tree_location::geometry) BETWEEN $3 AND $4
LIMIT $5
`

type GetIndividualTreesParams struct {
	SouthLat    interface{} `json:"south_lat"`
	NorthLat    interface{} `json:"north_lat"`
	WestLng     interface{} `json:"west_lng"`
	EastLng     interface{} `json:"east_lng"`
	ResultLimit int32       `json:"result_limit"`
}

type GetIndividualTreesRow struct {
	ID          string             `json:"id"`
	ProjectCode string             `json:"project_code"`
	TreeNumber  int32              `json:"tree_number"`
	DonorID     string             `json:"donor_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	PlantedAt   pgtype.Timestamptz `json:"planted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Metadata    []byte             `json:"metadata"`
	DonorName   string             `json:"donor_name"`
	ProjectName string             `json:"project_name"`
}

// Zoom levels 13+: Return individual trees with details
func (q *Queries) GetIndividualTrees(ctx context.Context, arg GetIndividualTreesParams) ([]GetIndividualTreesRow, error) {
	rows, err := q.db.Query(ctx, getIndividualTrees,
		arg.SouthLat,
		arg.NorthLat,
		arg.WestLng,
		arg.EastLng,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetIndividualTreesRow{}
	for rows.Next() {
		var i GetIndividualTreesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectCode,
			&i.TreeNumber,
			&i.DonorID,
			&i.Latitude,
			&i.Longitude,
			&i.PlantedAt,
			&i.CreatedAt,
			&i.Metadata,
			&i.DonorName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreeByID = `-- name: GetTreeByID :one
SELECT 
    t.id,
    t.project_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata,
    d.donor_name,
    d.phone_number as donor_phone_number,
    tw.project_name,
    tw.metadata as project_metadata
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
JOIN core.project tw ON t.project_code = tw.project_code
WHERE t.id = $1
`

type GetTreeByIDRow struct {
	ID               string             `json:"id"`
	ProjectCode      string             `json:"project_code"`
	TreeNumber       int32              `json:"tree_number"`
	DonorID          string             `json:"donor_id"`
	Latitude         float64            `json:"latitude"`
	Longitude        float64            `json:"longitude"`
	PlantedAt        pgtype.Timestamptz `json:"planted_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	Metadata         []byte             `json:"metadata"`
	DonorName        string             `json:"donor_name"`
	DonorPhoneNumber string             `json:"donor_phone_number"`
	ProjectName      string             `json:"project_name"`
	ProjectMetadata  []byte             `json:"project_metadata"`
}

// Get a single tree by ID with full details
func (q *Queries) GetTreeByID(ctx context.Context, id string) (GetTreeByIDRow, error) {
	row := q.db.QueryRow(ctx, getTreeByID, id)
	var i GetTreeByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.Latitude,
		&i.Longitude,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
		&i.DonorName,
		&i.DonorPhoneNumber,
		&i.ProjectName,
		&i.ProjectMetadata,
	)
	return i, err
}

const getTreeByProjectCodeAndNumber = `-- name: GetTreeByProjectCodeAndNumber :one
SELECT 
    t.id,
    t.project_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata
FROM core.tree t
WHERE t.project_code = $1 AND t.tree_number = $2
`

type GetTreeByProjectCodeAndNumberParams struct {
	ProjectCode string `json:"project_code"`
	TreeNumber  int32  `json:"tree_number"`
}

type GetTreeByProjectCodeAndNumberRow struct {
	ID          string             `json:"id"`
	ProjectCode string             `json:"project_code"`
	TreeNumber  int32              `json:"tree_number"`
	DonorID     string             `json:"donor_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	PlantedAt   pgtype.Timestamptz `json:"planted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Metadata    []byte             `json:"metadata"`
}

// Get a single tree by project code and tree number
func (q *Queries) GetTreeByProjectCodeAndNumber(ctx context.Context, arg GetTreeByProjectCodeAndNumberParams) (GetTreeByProjectCodeAndNumberRow, error) {
	row := q.db.QueryRow(ctx, getTreeByProjectCodeAndNumber, arg.ProjectCode, arg.TreeNumber)
	var i GetTreeByProjectCodeAndNumberRow
	err := row.Scan(
		&i.ID,
		&i.ProjectCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.Latitude,
		&i.Longitude,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getTreeCount = `-- name: GetTreeCount :one
SELECT COUNT(*) as total
FROM core.tree t
WHERE ($1::CHAR(2) IS NULL OR t.project_code = $1)
`

// Get total tree count, optionally filtered by project
func (q *Queries) GetTreeCount(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, getTreeCount, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTreesByProjectCluster = `-- name: GetTreesByProjectCluster :many
SELECT 
    t.project_code,
    tw.project_name,
    COUNT(*) as tree_count,
    AVG(ST_Y(t.tree_location::geometry))::FLOAT as center_lat,
    AVG(ST_X(t.tree_location::geometry))::FLOAT as center_lng
FROM core.tree t
JOIN core.project tw ON t.project_code = tw.project_code
WHERE ST_Y(t.tree_location::geometry) BETWEEN $1 AND $2
  AND ST_X(t.tree_location::geometry) BETWEEN $3 AND $4
GROUP BY t.project_code, tw.project_name
`

type GetTreesByProjectClusterParams struct {
	SouthLat interface{} `json:"south_lat"`
	NorthLat interface{} `json:"north_lat"`
	WestLng  interface{} `json:"west_lng"`
	EastLng  interface{} `json:"east_lng"`
}

type GetTreesByProjectClusterRow struct {
	ProjectCode string  `json:"project_code"`
	ProjectName string  `json:"project_name"`
	TreeCount   int64   `json:"tree_count"`
	CenterLat   float64 `json:"center_lat"`
	CenterLng   float64 `json:"center_lng"`
}

// Zoom levels 1-8: Get tree counts grouped by project
func (q *Queries) GetTreesByProjectCluster(ctx context.Context, arg GetTreesByProjectClusterParams) ([]GetTreesByProjectClusterRow, error) {
	rows, err := q.db.Query(ctx, getTreesByProjectCluster,
		arg.SouthLat,
		arg.NorthLat,
		arg.WestLng,
		arg.EastLng,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreesByProjectClusterRow{}
	for rows.Next() {
		var i GetTreesByProjectClusterRow
		if err := rows.Scan(
			&i.ProjectCode,
			&i.ProjectName,
			&i.TreeCount,
			&i.CenterLat,
			&i.CenterLng,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreesByProjectCode = `-- name: GetTreesByProjectCode :many
SELECT 
    t.id,
    t.tree_number,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.metadata,
    d.donor_name
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
WHERE t.project_code = $1
ORDER BY t.tree_number
`

type GetTreesByProjectCodeRow struct {
	ID         string             `json:"id"`
	TreeNumber int32              `json:"tree_number"`
	Latitude   float64            `json:"latitude"`
	Longitude  float64            `json:"longitude"`
	PlantedAt  pgtype.Timestamptz `json:"planted_at"`
	Metadata   []byte             `json:"metadata"`
	DonorName  string             `json:"donor_name"`
}

// Get all trees in a specific project
func (q *Queries) GetTreesByProjectCode(ctx context.Context, projectCode string) ([]GetTreesByProjectCodeRow, error) {
	rows, err := q.db.Query(ctx, getTreesByProjectCode, projectCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreesByProjectCodeRow{}
	for rows.Next() {
		var i GetTreesByProjectCodeRow
		if err := rows.Scan(
			&i.ID,
			&i.TreeNumber,
			&i.Latitude,
			&i.Longitude,
			&i.PlantedAt,
			&i.Metadata,
			&i.DonorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

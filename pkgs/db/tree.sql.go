// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tree.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTree = `-- name: CreateTree :one
INSERT INTO core.tree (
    project_code,
    tree_number,
    donor_id,
    tree_location,
    planted_at,
    metadata
) VALUES (
    $1, $2, $3, ST_SetSRID(ST_MakePoint($4, $5), 4326)::geography, $6, $7
)
RETURNING id, project_code, tree_number, donor_id, planted_at, created_at, metadata
`

type CreateTreeParams struct {
	ProjectCode   string             `json:"project_code"`
	TreeNumber    int32              `json:"tree_number"`
	DonorID       string             `json:"donor_id"`
	StMakepoint   interface{}        `json:"st_makepoint"`
	StMakepoint_2 interface{}        `json:"st_makepoint_2"`
	PlantedAt     pgtype.Timestamptz `json:"planted_at"`
	Metadata      []byte             `json:"metadata"`
}

type CreateTreeRow struct {
	ID          string             `json:"id"`
	ProjectCode string             `json:"project_code"`
	TreeNumber  int32              `json:"tree_number"`
	DonorID     string             `json:"donor_id"`
	PlantedAt   pgtype.Timestamptz `json:"planted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Metadata    []byte             `json:"metadata"`
}

// Insert a new tree
func (q *Queries) CreateTree(ctx context.Context, arg CreateTreeParams) (CreateTreeRow, error) {
	row := q.db.QueryRow(ctx, createTree,
		arg.ProjectCode,
		arg.TreeNumber,
		arg.DonorID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.PlantedAt,
		arg.Metadata,
	)
	var i CreateTreeRow
	err := row.Scan(
		&i.ID,
		&i.ProjectCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getClusterDetail = `-- name: GetClusterDetail :one
SELECT 
    tw.project_code,
    tw.project_name,
    tw.metadata as project_metadata,
    COUNT(t.id) as tree_count,
    AVG(ST_Y(t.tree_location::geometry))::FLOAT as center_lat,
    AVG(ST_X(t.tree_location::geometry))::FLOAT as center_lng,
    MIN(t.planted_at)::timestamptz as first_planted,
    MAX(t.planted_at)::timestamptz as last_planted,
    COUNT(DISTINCT t.donor_id) as unique_donors
FROM core.project tw
LEFT JOIN core.tree t ON tw.project_code = t.project_code
WHERE tw.project_code = $1
GROUP BY tw.project_code, tw.project_name, tw.metadata
`

type GetClusterDetailRow struct {
	ProjectCode     string             `json:"project_code"`
	ProjectName     string             `json:"project_name"`
	ProjectMetadata []byte             `json:"project_metadata"`
	TreeCount       int64              `json:"tree_count"`
	CenterLat       float64            `json:"center_lat"`
	CenterLng       float64            `json:"center_lng"`
	FirstPlanted    pgtype.Timestamptz `json:"first_planted"`
	LastPlanted     pgtype.Timestamptz `json:"last_planted"`
	UniqueDonors    int64              `json:"unique_donors"`
}

// Get detailed statistics for a project cluster
func (q *Queries) GetClusterDetail(ctx context.Context, projectCode string) (GetClusterDetailRow, error) {
	row := q.db.QueryRow(ctx, getClusterDetail, projectCode)
	var i GetClusterDetailRow
	err := row.Scan(
		&i.ProjectCode,
		&i.ProjectName,
		&i.ProjectMetadata,
		&i.TreeCount,
		&i.CenterLat,
		&i.CenterLng,
		&i.FirstPlanted,
		&i.LastPlanted,
		&i.UniqueDonors,
	)
	return i, err
}

const getTreeByID = `-- name: GetTreeByID :one
SELECT 
    t.id,
    t.project_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata,
    d.donor_name,
    d.phone_number as donor_phone_number,
    tw.project_name,
    tw.metadata as project_metadata
FROM core.tree t
JOIN core.donor d ON t.donor_id = d.id
JOIN core.project tw ON t.project_code = tw.project_code
WHERE t.id = $1
`

type GetTreeByIDRow struct {
	ID               string             `json:"id"`
	ProjectCode      string             `json:"project_code"`
	TreeNumber       int32              `json:"tree_number"`
	DonorID          string             `json:"donor_id"`
	Latitude         float64            `json:"latitude"`
	Longitude        float64            `json:"longitude"`
	PlantedAt        pgtype.Timestamptz `json:"planted_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	Metadata         []byte             `json:"metadata"`
	DonorName        string             `json:"donor_name"`
	DonorPhoneNumber string             `json:"donor_phone_number"`
	ProjectName      string             `json:"project_name"`
	ProjectMetadata  []byte             `json:"project_metadata"`
}

// Get a single tree by ID with full details
func (q *Queries) GetTreeByID(ctx context.Context, id string) (GetTreeByIDRow, error) {
	row := q.db.QueryRow(ctx, getTreeByID, id)
	var i GetTreeByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.Latitude,
		&i.Longitude,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
		&i.DonorName,
		&i.DonorPhoneNumber,
		&i.ProjectName,
		&i.ProjectMetadata,
	)
	return i, err
}

const getTreeByProjectCodeAndNumber = `-- name: GetTreeByProjectCodeAndNumber :one
SELECT 
    t.id,
    t.project_code,
    t.tree_number,
    t.donor_id,
    ST_Y(t.tree_location::geometry)::FLOAT as latitude,
    ST_X(t.tree_location::geometry)::FLOAT as longitude,
    t.planted_at,
    t.created_at,
    t.metadata
FROM core.tree t
WHERE t.project_code = $1 AND t.tree_number = $2
`

type GetTreeByProjectCodeAndNumberParams struct {
	ProjectCode string `json:"project_code"`
	TreeNumber  int32  `json:"tree_number"`
}

type GetTreeByProjectCodeAndNumberRow struct {
	ID          string             `json:"id"`
	ProjectCode string             `json:"project_code"`
	TreeNumber  int32              `json:"tree_number"`
	DonorID     string             `json:"donor_id"`
	Latitude    float64            `json:"latitude"`
	Longitude   float64            `json:"longitude"`
	PlantedAt   pgtype.Timestamptz `json:"planted_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	Metadata    []byte             `json:"metadata"`
}

// Get a single tree by project code and tree number
func (q *Queries) GetTreeByProjectCodeAndNumber(ctx context.Context, arg GetTreeByProjectCodeAndNumberParams) (GetTreeByProjectCodeAndNumberRow, error) {
	row := q.db.QueryRow(ctx, getTreeByProjectCodeAndNumber, arg.ProjectCode, arg.TreeNumber)
	var i GetTreeByProjectCodeAndNumberRow
	err := row.Scan(
		&i.ID,
		&i.ProjectCode,
		&i.TreeNumber,
		&i.DonorID,
		&i.Latitude,
		&i.Longitude,
		&i.PlantedAt,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFileByID = `-- name: GetFileByID :one
SELECT id, file_store, file_store_id, file_path, file_name, file_type, file_url, file_expiration
FROM core.file
WHERE id = $1
`

func (q *Queries) GetFileByID(ctx context.Context, fileID string) (CoreFile, error) {
	row := q.db.QueryRow(ctx, getFileByID, fileID)
	var i CoreFile
	err := row.Scan(
		&i.ID,
		&i.FileStore,
		&i.FileStoreID,
		&i.FilePath,
		&i.FileName,
		&i.FileType,
		&i.FileUrl,
		&i.FileExpiration,
	)
	return i, err
}

const getLatestTreeUpdateFile = `-- name: GetLatestTreeUpdateFile :one
SELECT tu.update_date, f.id, f.file_store, f.file_store_id, f.file_path, f.file_name, f.file_type, f.file_url, f.file_expiration
FROM core.file AS f
    JOIN core.tree_update AS tu ON f.id = tu.file_id
WHERE tu.tree_id = $1
ORDER BY tu.update_date DESC
LIMIT 1
`

type GetLatestTreeUpdateFileRow struct {
	UpdateDate     pgtype.Timestamptz `json:"update_date"`
	ID             string             `json:"id"`
	FileStore      string             `json:"file_store"`
	FileStoreID    pgtype.Text        `json:"file_store_id"`
	FilePath       pgtype.Text        `json:"file_path"`
	FileName       pgtype.Text        `json:"file_name"`
	FileType       pgtype.Text        `json:"file_type"`
	FileUrl        pgtype.Text        `json:"file_url"`
	FileExpiration pgtype.Timestamptz `json:"file_expiration"`
}

func (q *Queries) GetLatestTreeUpdateFile(ctx context.Context, treeID string) (GetLatestTreeUpdateFileRow, error) {
	row := q.db.QueryRow(ctx, getLatestTreeUpdateFile, treeID)
	var i GetLatestTreeUpdateFileRow
	err := row.Scan(
		&i.UpdateDate,
		&i.ID,
		&i.FileStore,
		&i.FileStoreID,
		&i.FilePath,
		&i.FileName,
		&i.FileType,
		&i.FileUrl,
		&i.FileExpiration,
	)
	return i, err
}

const getTreeUpdateFiles = `-- name: GetTreeUpdateFiles :many
SELECT f.id, f.file_store, f.file_store_id, f.file_path, f.file_name, f.file_type, f.file_url, f.file_expiration
FROM core.file AS f
    JOIN core.tree_update AS tu ON f.id = tu.file_id
WHERE tu.tree_id = $1
ORDER BY tu.update_date DESC
`

func (q *Queries) GetTreeUpdateFiles(ctx context.Context, treeID string) ([]CoreFile, error) {
	rows, err := q.db.Query(ctx, getTreeUpdateFiles, treeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoreFile{}
	for rows.Next() {
		var i CoreFile
		if err := rows.Scan(
			&i.ID,
			&i.FileStore,
			&i.FileStoreID,
			&i.FilePath,
			&i.FileName,
			&i.FileType,
			&i.FileUrl,
			&i.FileExpiration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFile = `-- name: UpsertFile :one
INSERT INTO core.file (
    file_store,
    file_store_id,
    file_path,
    file_name,
    file_url,
    file_type,
    file_expiration
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
ON CONFLICT (file_store_id) DO UPDATE SET
    file_store = EXCLUDED.file_store,
    file_path = EXCLUDED.file_path,
    file_name = EXCLUDED.file_name,
    file_url = EXCLUDED.file_url,
    file_type = EXCLUDED.file_type,
    file_expiration = EXCLUDED.file_expiration
RETURNING 
    id,
    (xmax != 0) AS was_updated
`

type UpsertFileParams struct {
	FileStore      string             `json:"file_store"`
	FileStoreID    pgtype.Text        `json:"file_store_id"`
	FilePath       pgtype.Text        `json:"file_path"`
	FileName       pgtype.Text        `json:"file_name"`
	FileUrl        pgtype.Text        `json:"file_url"`
	FileType       pgtype.Text        `json:"file_type"`
	FileExpiration pgtype.Timestamptz `json:"file_expiration"`
}

type UpsertFileRow struct {
	ID         string `json:"id"`
	WasUpdated bool   `json:"was_updated"`
}

func (q *Queries) UpsertFile(ctx context.Context, arg UpsertFileParams) (UpsertFileRow, error) {
	row := q.db.QueryRow(ctx, upsertFile,
		arg.FileStore,
		arg.FileStoreID,
		arg.FilePath,
		arg.FileName,
		arg.FileUrl,
		arg.FileType,
		arg.FileExpiration,
	)
	var i UpsertFileRow
	err := row.Scan(&i.ID, &i.WasUpdated)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tree_update.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFile = `-- name: CreateFile :one
INSERT INTO core.file (
    file_store,
    file_store_id,
    file_path,
    file_name,
    file_type,
    file_expiration
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, file_store, file_store_id, file_path, file_name, file_type, file_expiration
`

type CreateFileParams struct {
	FileStore      string             `json:"file_store"`
	FileStoreID    pgtype.Text        `json:"file_store_id"`
	FilePath       pgtype.Text        `json:"file_path"`
	FileName       pgtype.Text        `json:"file_name"`
	FileType       pgtype.Text        `json:"file_type"`
	FileExpiration pgtype.Timestamptz `json:"file_expiration"`
}

// Insert a new file record
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (CoreFile, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.FileStore,
		arg.FileStoreID,
		arg.FilePath,
		arg.FileName,
		arg.FileType,
		arg.FileExpiration,
	)
	var i CoreFile
	err := row.Scan(
		&i.ID,
		&i.FileStore,
		&i.FileStoreID,
		&i.FilePath,
		&i.FileName,
		&i.FileType,
		&i.FileExpiration,
	)
	return i, err
}

const createTreeUpdate = `-- name: CreateTreeUpdate :one
INSERT INTO core.tree_update (
    tree_id,
    update_date,
    file_id
) VALUES (
    $1, $2, $3
)
RETURNING tree_id, update_date, file_id
`

type CreateTreeUpdateParams struct {
	TreeID     string             `json:"tree_id"`
	UpdateDate pgtype.Timestamptz `json:"update_date"`
	FileID     string             `json:"file_id"`
}

// Insert a new tree update
func (q *Queries) CreateTreeUpdate(ctx context.Context, arg CreateTreeUpdateParams) (CoreTreeUpdate, error) {
	row := q.db.QueryRow(ctx, createTreeUpdate, arg.TreeID, arg.UpdateDate, arg.FileID)
	var i CoreTreeUpdate
	err := row.Scan(&i.TreeID, &i.UpdateDate, &i.FileID)
	return i, err
}

const deleteTreeUpdate = `-- name: DeleteTreeUpdate :exec
DELETE FROM core.tree_update
WHERE tree_id = $1 AND update_date = $2
`

type DeleteTreeUpdateParams struct {
	TreeID     string             `json:"tree_id"`
	UpdateDate pgtype.Timestamptz `json:"update_date"`
}

// Delete a specific tree update
func (q *Queries) DeleteTreeUpdate(ctx context.Context, arg DeleteTreeUpdateParams) error {
	_, err := q.db.Exec(ctx, deleteTreeUpdate, arg.TreeID, arg.UpdateDate)
	return err
}

const getFile = `-- name: GetFile :one
SELECT id, file_store, file_store_id, file_path, file_name, file_type, file_expiration
FROM core.file
WHERE id = $1
`

// Get a file by ID
func (q *Queries) GetFile(ctx context.Context, id string) (CoreFile, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i CoreFile
	err := row.Scan(
		&i.ID,
		&i.FileStore,
		&i.FileStoreID,
		&i.FilePath,
		&i.FileName,
		&i.FileType,
		&i.FileExpiration,
	)
	return i, err
}

const getLatestTreeUpdate = `-- name: GetLatestTreeUpdate :one
SELECT 
    tu.tree_id,
    tu.update_date,
    tu.file_id,
    f.file_store,
    f.file_store_id,
    f.file_path,
    f.file_name,
    f.file_type,
    f.file_expiration
FROM core.tree_update tu
JOIN core.file f ON tu.file_id = f.id
WHERE tu.tree_id = $1
ORDER BY tu.update_date DESC
LIMIT 1
`

type GetLatestTreeUpdateRow struct {
	TreeID         string             `json:"tree_id"`
	UpdateDate     pgtype.Timestamptz `json:"update_date"`
	FileID         string             `json:"file_id"`
	FileStore      string             `json:"file_store"`
	FileStoreID    pgtype.Text        `json:"file_store_id"`
	FilePath       pgtype.Text        `json:"file_path"`
	FileName       pgtype.Text        `json:"file_name"`
	FileType       pgtype.Text        `json:"file_type"`
	FileExpiration pgtype.Timestamptz `json:"file_expiration"`
}

// Get the most recent update for a tree
func (q *Queries) GetLatestTreeUpdate(ctx context.Context, treeID string) (GetLatestTreeUpdateRow, error) {
	row := q.db.QueryRow(ctx, getLatestTreeUpdate, treeID)
	var i GetLatestTreeUpdateRow
	err := row.Scan(
		&i.TreeID,
		&i.UpdateDate,
		&i.FileID,
		&i.FileStore,
		&i.FileStoreID,
		&i.FilePath,
		&i.FileName,
		&i.FileType,
		&i.FileExpiration,
	)
	return i, err
}

const getRecentUpdates = `-- name: GetRecentUpdates :many
SELECT 
    tu.tree_id,
    tu.update_date,
    tu.file_id,
    t.tree_number,
    t.town_code,
    tw.town_name,
    f.file_name,
    f.file_path
FROM core.tree_update tu
JOIN core.tree t ON tu.tree_id = t.id
JOIN core.town tw ON t.town_code = tw.town_code
JOIN core.file f ON tu.file_id = f.id
ORDER BY tu.update_date DESC
LIMIT $1
`

type GetRecentUpdatesRow struct {
	TreeID     string             `json:"tree_id"`
	UpdateDate pgtype.Timestamptz `json:"update_date"`
	FileID     string             `json:"file_id"`
	TreeNumber int32              `json:"tree_number"`
	TownCode   string             `json:"town_code"`
	TownName   string             `json:"town_name"`
	FileName   pgtype.Text        `json:"file_name"`
	FilePath   pgtype.Text        `json:"file_path"`
}

// Get recent updates across all trees
func (q *Queries) GetRecentUpdates(ctx context.Context, limit int32) ([]GetRecentUpdatesRow, error) {
	rows, err := q.db.Query(ctx, getRecentUpdates, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentUpdatesRow{}
	for rows.Next() {
		var i GetRecentUpdatesRow
		if err := rows.Scan(
			&i.TreeID,
			&i.UpdateDate,
			&i.FileID,
			&i.TreeNumber,
			&i.TownCode,
			&i.TownName,
			&i.FileName,
			&i.FilePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreeUpdates = `-- name: GetTreeUpdates :many
SELECT 
    tu.tree_id,
    tu.update_date,
    tu.file_id,
    f.file_store,
    f.file_store_id,
    f.file_path,
    f.file_name,
    f.file_type,
    f.file_expiration
FROM core.tree_update tu
JOIN core.file f ON tu.file_id = f.id
WHERE tu.tree_id = $1
ORDER BY tu.update_date DESC
`

type GetTreeUpdatesRow struct {
	TreeID         string             `json:"tree_id"`
	UpdateDate     pgtype.Timestamptz `json:"update_date"`
	FileID         string             `json:"file_id"`
	FileStore      string             `json:"file_store"`
	FileStoreID    pgtype.Text        `json:"file_store_id"`
	FilePath       pgtype.Text        `json:"file_path"`
	FileName       pgtype.Text        `json:"file_name"`
	FileType       pgtype.Text        `json:"file_type"`
	FileExpiration pgtype.Timestamptz `json:"file_expiration"`
}

// Get all updates for a specific tree
func (q *Queries) GetTreeUpdates(ctx context.Context, treeID string) ([]GetTreeUpdatesRow, error) {
	rows, err := q.db.Query(ctx, getTreeUpdates, treeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreeUpdatesRow{}
	for rows.Next() {
		var i GetTreeUpdatesRow
		if err := rows.Scan(
			&i.TreeID,
			&i.UpdateDate,
			&i.FileID,
			&i.FileStore,
			&i.FileStoreID,
			&i.FilePath,
			&i.FileName,
			&i.FileType,
			&i.FileExpiration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreesWithUpdateCount = `-- name: GetTreesWithUpdateCount :many
SELECT 
    t.id,
    t.tree_number,
    t.town_code,
    tw.town_name,
    COUNT(tu.file_id) as update_count,
    MAX(tu.update_date) as last_updated
FROM core.tree t
JOIN core.town tw ON t.town_code = tw.town_code
LEFT JOIN core.tree_update tu ON t.id = tu.tree_id
WHERE ($1::CHAR(2) IS NULL OR t.town_code = $1)
GROUP BY t.id, t.tree_number, t.town_code, tw.town_name
ORDER BY last_updated DESC NULLS LAST
`

type GetTreesWithUpdateCountRow struct {
	ID          string      `json:"id"`
	TreeNumber  int32       `json:"tree_number"`
	TownCode    string      `json:"town_code"`
	TownName    string      `json:"town_name"`
	UpdateCount int64       `json:"update_count"`
	LastUpdated interface{} `json:"last_updated"`
}

// Get trees with their update counts
func (q *Queries) GetTreesWithUpdateCount(ctx context.Context, dollar_1 string) ([]GetTreesWithUpdateCountRow, error) {
	rows, err := q.db.Query(ctx, getTreesWithUpdateCount, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreesWithUpdateCountRow{}
	for rows.Next() {
		var i GetTreesWithUpdateCountRow
		if err := rows.Scan(
			&i.ID,
			&i.TreeNumber,
			&i.TownCode,
			&i.TownName,
			&i.UpdateCount,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
